# do nothing if non-interactive
[[ $- != *i* ]] && return

# appends to the histfile instead of overwriting
shopt -s histappend

# bash should check the window size after every command
shopt -s checkwinsize

# bash matches filenames in a case-insensitive fashion when  performing
# pathname expansion
shopt -s nocaseglob

# allows recursive matching in cd via ** (if supported)
shopt -s autocd 2> /dev/null

# allows recursive globbing via **
shopt -s globstar 2> /dev/null

# minor  errors in the spelling of a directory component in a cd command will
# be corrected
shopt -s cdspell

# editor
if type vim &>/dev/null; then
    export EDITOR=vim
else
    export EDITOR=vi
fi

# ls
case $(uname) in
    Darwin)
        export CLICOLOR_FORCE=1
        alias ls="\ls -bCFh"
        alias ll="\ls -bCFh -l"
        alias la="\ls -bCFh -la"
        ;;

    Linux)
        alias ls="\ls --color=always -bCFh"
        alias ll="\ls --color=always -bCFh -l"
        alias la="\ls --color=always -bCFh -la"
        ;;
esac

# less
export LESS="-FRXi"

# lesspipe
if type lesspipe &>/dev/null; then
    eval $(lesspipe) &>/dev/null
elif type lesspipe.sh &>/dev/null; then
    export LESSOPEN="| $(brew --prefix)/bin/lesspipe.sh %s"
    export LESS_ADVANCED_PREPROCESSOR=1
elif type src-hilite-lesspipe.sh &>/dev/null; then
    export LESSOPEN="| src-hilite-lesspipe.sh %s"
elif [[ -f /usr/share/source-highlight/src-hilite-lesspipe.sh ]]; then
    export LESSOPEN="| /usr/share/source-highlight/src-hilite-lesspipe.sh %s"
fi

# man
man() {
    env \
    LESS_TERMCAP_mb=$(printf "\e[1;31m") \
    LESS_TERMCAP_md=$(printf "\e[1;31m") \
    LESS_TERMCAP_me=$(printf "\e[0m") \
    LESS_TERMCAP_se=$(printf "\e[0m") \
    LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
    LESS_TERMCAP_ue=$(printf "\e[0m") \
    LESS_TERMCAP_us=$(printf "\e[1;32m") \
    man "$@"
}

# screen
alias scr="screen -d -RR"

# prompt

# username@host for other accounts
prompt_host="\u@\h"

# shortens prompt_host if known username
usernames=( acolomba )
for username in "${usernames[@]}"; do
    if [[ $USER = $username ]]; then
        # only host for my account
        prompt_host="\h"
    fi
done

# suffix depends on identity
if [[ $(id -u) == 0 ]]; then
    # pound for root
    prompt_suffix="#"
else
    # symbol otherwise
    prompt_suffix=">"
fi

# colors
start_host_color="\[\e[1;31m\]"
end_host_color="\[\e[m\]"
start_pwd_color="\[\e[1;34m\]"
end_pwd_color="\[\e[m\]"

export PS1="${start_host_color}${prompt_host}${end_host_color}:${start_pwd_color}\w${end_pwd_color} ${prompt_suffix} "

# prompt command for use in screen multiplexer
case $TERM in
    screen)
        export PROMPT_COMMAND='echo -n -e "\033k\033\\"'
        ;;
esac
# direnv
if type direnv &>/dev/null; then
    eval "$(direnv hook bash)"
    export DIRENV_LOG_FORMAT=
fi

# fzf
if type fzf &>/dev/null && type fdfind &>/dev/null && [[ $- == *i* ]]; then
    case $(uname) in
        Darwin)
            eval "$(fzf --bash)"
            ;;

        Linux)
            . /usr/share/doc/fzf/examples/key-bindings.bash
            ;;
    esac
fi

# autojump
case $(uname) in
    Darwin)
        [[ -f $(brew --prefix)/etc/profile.d/autojump.sh ]] \
            && . $(brew --prefix)/etc/profile.d/autojump.sh
        ;;

    Linux)
        [[ -f /usr/share/autojump/autojump.sh ]] \
            && . /usr/share/autojump/autojump.sh
        ;;
esac

# completion; this runs only on 4+
if (( $BASH_VERSINFO >= 4 )); then
    case $(uname) in
        Darwin)
            [[ -r "$(brew --prefix)/etc/profile.d/bash_completion.sh" ]] && . "$(brew --prefix)/etc/profile.d/bash_completion.sh"
            ;;

        Linux)
            [[ $PS1 && -f /usr/share/bash-completion/bash_completion ]] && \
                . /usr/share/bash-completion/bash_completion
            ;;
    esac
fi

# sources local bashrc
[[ -r ~/.bashrc_local ]] && . ~/.bashrc_local

# cd home
cd
